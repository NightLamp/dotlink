#!/usr/bin/python3

desc = '''dotlink automates the spreading of dotfiles to new systems and uses 
links to dotfile repos to make the use of version control easier.'''


import json
import subprocess
import sys
import argparse
import os.path


# globals
G_args = None
json_path = 'test_data.json'

def verbose_print(msg):
    if G_args.verbose:
        print(msg)
    return

# get arguments and set flags as necessary
# -l --link [FILE] 
# -v --verbose
# -h --help
# -f --force
#TODO: ADD
#TODO: REMOVE
#TODO: LIST
def process_args():
    global G_args
    # init parser and add arg opts
    parser = argparse.ArgumentParser(description = desc)
    parser.add_argument("-l", "--link", metavar="FILE", nargs='?', help="link the given file to the correct position")
    parser.add_argument("-v", "--verbose", help='be verbose during execution', action='store_true')
    parser.add_argument("-f", "--force", help='force overriding existing files', action='store_true')

    G_args = parser.parse_args()
    return 



# calls the link command to make a soft link from 'link' to 'target'
# is a wrapper for ln
def link_wrapper(source, dest):
    # make symlink 
    link_args = ['ln', '-s', source, dest]
    subprocess.call(link_args)
    return
    


def link_dotfile(source, dest):
    #TODO: check that the sibprocesses complete properly
    # expand the home directory '~'
    source = os.path.expanduser(source)
    dest = os.path.expanduser(dest)

    # check if already linked correctly
    if os.path.islink(dest):
        #TODO: what do when already link and force?
        verbose_print('\tlink already at {}'.format(dest))
        return
    # catch any files in the way
    elif os.path.exists(dest):
        # remove file if force flag given
        if G_args.force:
            #TODO: remove/move/rename file?
            rm_args = ['rm', '-r', dest]
            verbose_print('\trm {}'.format(dest))
            subprocess.call(rm_args)
        else:
            print('error: cannot create symlink at {}'.format(dest))
            sys.exit()

    link_wrapper(source, dest)
    verbose_print('\tlink made from {} to {}'.format(dest, source))
    return


# loads the json file into a dictionary
# fails if cannot read or json is malformed 
def load_repos_from_json(filename):
    try:
        with open(filename, 'r') as json_file:
            json_obj = json.load(json_file)
            repos = json_obj['dotdirs']
    except IOError:
        print('json file {} doesn\'t exist'.format(filename))
        sys.exit()
    except json.JSONDecodeError:
        print('json file {} is malformed'.format(filename))
        sys.exit()
    return repos
    


def add_path(path, filename, repo_name):
    # load repo
    repos = load_repo_from_json(json_path)
    repo = repos[repo_name]
    ##TODO: below
    # add repo to json file
    ##repo[path] = 

    
    pass



# iterates through all repos stored in json file
def iterate_through_repos(repos):
    # iterate through dotfile repo
    for repo in repos:
        verbose_print('repo: ' + repo['location'])
        
        # iterate through each target location
        for target in repo['contents']:
            verbose_print('target: ' + target['directory'])
            
            # iterate throgh each file
            for dotfile in target['files']:
                
                link_dir = repo['location'] + dotfile['name']
                target_dir = target['directory'] + dotfile['name']
                link_dotfile(link_dir, target_dir)
        
    return 





def main():
    process_args()
    repos = load_repos_from_json(json_path)
    iterate_through_repos(repos) 
    return


# run main if executed as script
if __name__ == '__main__':
    main()
