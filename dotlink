#!/usr/bin/python3

desc = '''dotlink automates the spreading of dotfiles to new systems and uses 
links to dotfile repos to make the use of version control easier.'''


import json
import subprocess
import sys
import argparse
import os.path


# globals
G_args = None


def verbose_print(msg):
    if G_args.verbose:
        print(msg)
    return

# get arguments and set flags as necessary
# -l --link [FILE] 
# -v --verbose
# -h --help
# -f --force
#TODO: ADD
#TODO: REMOVE
#TODO: LIST
def process_args():
    global G_args
    # init parser and add arg opts
    parser = argparse.ArgumentParser(description = desc)
    parser.add_argument("-l", "--link", metavar="FILE", nargs='?', help="link the given file to the correct position")
    parser.add_argument("-v", "--verbose", help='be verbose during execution', action='store_true')
    parser.add_argument("-f", "--force", help='force overriding existing files', action='store_true')

    G_args = parser.parse_args()
    return 



# calls the link command to make a soft link from 'link' to 'target'
# is a wrapper for ln
def link_wrapper(source, dest):
    # expand the home directory '~'
    source = os.path.expanduser(source)
    dest = os.path.expanduser(dest)

    #     check if already sourceed correctly
    if os.path.islink(dest):
        #TODO: what do when already source?
        verbose_print('\tlink already at {}'.format(dest))
        return
    # check if paths are already used
    elif os.path.exists(dest):
        if G_args.force:
            #TODO: remove/move/rename file?
            verbose_print('\tpretend: rm {}'.format(dest))
        else:
            print('error: cannot create symlink at {}'.format(dest))
            sys.exit()
    #TODO: make symlink 
    verbose_print('\tpretend: {} -> {}'.format(dest,source))

    return


# loads the json file into a dictionary
# fails if cannot read or json is malformed 
def load_repos_from_json(filename):
    try:
        with open(filename, 'r') as json_file:
            json_obj = json.load(json_file)
            repos = json_obj['dotdirs']
    except IOError:
        print('json file {} doesn\'t exist'.format(filename))
        sys.exit()
    except json.JSONDecodeError:
        print('json file {} is malformed'.format(filename))
        sys.exit()
    return repos
    

# iterates through all repos stored in json file
def iterate_through_repos(repos):
    # iterate through dotfile repo
    for repo in repos:
        verbose_print('repo: ' + repo['location'])
        
        # iterate through each target location
        for target in repo['contents']:
            verbose_print('target: ' + target['directory'])
            
            # iterate throgh each file
            for dotfile in target['files']:
                
                link_dir = repo['location'] + dotfile['name']
                target_dir = target['directory'] + dotfile['name']
                link_wrapper(link_dir, target_dir)
        
    return 





def main():
    process_args()
    repos = load_repos_from_json('test_data.json')
    iterate_through_repos(repos) 
    return


# run main if executed as script
if __name__ == '__main__':
    main()
