#!/usr/bin/python3


desc = '''dotlink automates the spreading of dotfiles to new systems and uses 
links to dotfile repos to make the use of version control easier.'''
# Options:
# -v --verbose
# -h --help
# -f --force
# -a --ask


import json
import subprocess
import sys
import argparse
import os
from pathlib import Path


# globals
G_args = None
json_path = 'lm.json'
working_dir = Path.cwd()




### Helper functions ###

# print msg only if verbose flag is given
def verbose_print(msg):
    if G_args.verbose:
        print(msg)
    return


### User Interface ###

# process cli options and store in G_args
#TODO: -l --link [FILE] 
#TODO: -d --dir 
#TODO: ADD
#TODO: REMOVE
#TODO: LIST
def process_args():
    global G_args

    # help messages: 
    verbose_help = 'be verbose during execution'
    force_help   = 'force overriding existing files'
    ask_help     = 'ask before removing files'

    # init parser and add arg opts
    parser = argparse.ArgumentParser(description = desc)
    parser.add_argument("-v", "--verbose", help=verbose_help, action='store_true')
    parser.add_argument("-f", "--force", help=force_help, action='store_true')
    parser.add_argument("-a", "--ask", help=ask_help, action='store_true')
    #parser.add_argument("-l", "--link", metavar="FILE", nargs='?', help="link the given file to the correct position")
    G_args = parser.parse_args()
    return 


# ask to execute rm command
def ask_to_remove(path):
    yes = ['y', 'yes', 'Y', 'YES']
    no = ['n', 'no', 'No', 'NO', 'N']
    resp = input('remove [{}]? '.format(path))

    if resp in yes:
        return True    
    elif resp in no:
        return False
    else:
        print('error: invalid response')
        sys.exit()
    

### Command Wrappers ###

# calls the link command to make a soft link from 'source' to 'dest'
# is a wrapper for ln
def link_wrapper(source, dest):
    # make symlink 
    link_args = ['ln', '-s', source, dest]
    subprocess.call(link_args)
    return
    

# calls the rm command to remove the file at 'path' recursively
def rm_wrapper(path):
    rm_args = ['rm', '-r', path]
    subprocess.call(rm_args)


### Linking Functions ###


def link_dotfile(target, dotfile):
    
    target = Path(target).expanduser()
    dotfile = Path(working_dir / dotfile)
    
    # check target and dotfile exist
    if not target.exists(): 
        print('eror: ' + str(target) + ' does not exist')
        sys.exit()
    elif not dotfile.exists():
        print('eror: ' + str(dotfile.stem) + ' does not exist')
        sys.exit()

    # location that the dotfile will be placed    
    dotfile_location = target / dotfile.stem

    if (dotfile_location.exists()):
        if not G_args.force:
            # ask if its ok to remove offending file
            if G_args.ask:
                ok_to_remove = ask_to_remove(dotfile_location)
                if ok_to_remove:
                    rm_wrapper(dotfile_location)
                    verbose_print('\trm {}'.format(dotfile_location))

        else: # if forced
            rm_wrapper(dotfile_location)
            verbose_print('\trm {}'.format(dotfile_location))
    else: # if file exists
        return 

    link_wrapper(dotfile, target)
    target = str(target)
    dotfile = str(dotfile.stem)
    verbose_print('\tlinking {} to {}'.format(dotfile, target))
    return
          



# stub used to debug linking
def link_dotfile_stub(target, dotfile):

    target = Path(target).expanduser()
    dotfile = Path(working_dir / dotfile)
    
    # check target and dotfile exist
    if not target.exists() or not dotfile.exists():
        print('eror: target or dotfile does not exist')
        sys.exit()

    # print the fake link
    target = str(target)
    dotfile = dotfile.stem
    print('\tlinking \'' + dotfile + '\' to ' + target)    

    return



# links all files within a repo
def link_repo(repo):
    # iterate through each target location
    for target in repo:
        verbose_print('target: ' + target)

        # iterate throgh each file
        for dotfile in repo[target]:
            #link_dotfile_stub(target, dotfile)
            link_dotfile(target, dotfile)
    return



### JSON File Operations ###

# loads the json file into a dictionary
# fails if cannot read or json is malformed 
def load_repo_from_json(filename):
    try:
        with open(filename, 'r') as json_file:
            repo = json.load(json_file)
    except IOError:
        print('error: json file {} doesn\'t exist'.format(filename))
        sys.exit()
    except json.JSONDecodeError:
        print('error: json file {} is malformed'.format(filename))
        sys.exit()
    return repo
    

##TODO: refactor for new layout
# adds path to the json file
def add_path_to_json(path, filename, repo_name):
    # load repo
    repos = load_repo_from_json(json_path)
    
    # set repo if can be found
    repo = None 
    for r in repos:
        if r['location'] == repo_name:
            repo = r
    if repo == None:
        print('error: no repo called {}'.format(repo_name))

    # add repo to json dict
    print(repo)
    repo_list = repo['contents']
    # DEBUG return repo for checking
    return repo
    

### Main Function ###

def main():

    process_args()
    repo = load_repo_from_json(json_path)
    link_repo(repo)
    return


# run main if executed as script.
# declares all functions before running main
if __name__ == '__main__':
    main()
