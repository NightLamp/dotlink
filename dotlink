#!/usr/bin/python3


desc = '''dotlink automates the spreading of dotfiles to new systems and uses 
links to dotfile repos to make the use of version control easier.'''
# Options:
# -v --verbose
# -h --help
# -f --force
# -a --ask



# globals
G_args = None
json_path = 'linkmap.json'


import json
import subprocess
import sys
import argparse
import os.path



### Helper functions ###

# print msg only if verbose flag is given
def verbose_print(msg):
    if G_args.verbose:
        print(msg)
    return


### User Interface ###

# process cli options and store in G_args
#TODO: -l --link [FILE] 
#TODO: ADD
#TODO: REMOVE
#TODO: LIST
def process_args():
    global G_args

    # help messages: 
    verbose_help = 'be verbose during execution'
    force_help   = 'force overriding existing files'
    ask_help     = 'ask before removing files'

    # init parser and add arg opts
    parser = argparse.ArgumentParser(description = desc)
    parser.add_argument("-v", "--verbose", help=verbose_help, action='store_true')
    parser.add_argument("-f", "--force", help=force_help, action='store_true')
    parser.add_argument("-a", "--ask", help=ask_help, action='store_true')
    #parser.add_argument("-l", "--link", metavar="FILE", nargs='?', help="link the given file to the correct position")
    G_args = parser.parse_args()
    return 


# ask to execute rm command
def ask_to_remove(path):
    yes = ['y', 'yes', 'Y', 'YES']
    no = ['n', 'no', 'No', 'NO', 'N']
    resp = input('remove [{}]? '.format(path))
    removed = False
    
    if resp in yes:
        rm_wrapper(path) 
        verbose_print('\trm {}'.format(path))
        removed = True
    elif resp not in no:
        # todo: check this doesn't happen forever
        ask_to_remove(path)
    return removed
    

### Command Wrappers ###

# calls the link command to make a soft link from 'source' to 'dest'
# is a wrapper for ln
def link_wrapper(source, dest):
    # make symlink 
    link_args = ['ln', '-s', source, dest]
    subprocess.call(link_args)
    return
    

# calls the rm command to remove the file at 'path' recursively
def rm_wrapper(path):
    rm_args = ['rm', '-r', path]
    subprocess.call(rm_args)


### Linking Functions ###

# links a singular dotfile from 'source' to 'dest', checking for validity
def link_dotfile(source, dest):
    #TODO: check that the sibprocesses complete properly
    #TODO: reorganise the structure, too messy

    # expand the home directory '~'
    source = os.path.expanduser(source)
    dest = os.path.expanduser(dest)

    ok_to_link = False
    # catch any files in the way
    if os.path.exists(dest):
        # remove file if force flag given
        if G_args.force:
            # check if need to ask
            if G_args.ask:
                if ask_to_remove(dest):
                    ok_to_link = True
            else:
                rm_wrapper(dest)
                verbose_print('\trm {}'.format(dest))
                ok_to_link = True
        else:
            print('error: file already at {}'.format(dest))
            sys.exit()
    else:
        ok_to_link = True

    if ok_to_link:
        # just make link if no file or link exists at dest path
        link_wrapper(source, dest)
        verbose_print('\tlink made from {} to {}'.format(dest, source))
    return


# links all files within a repo
def link_repo(repo):
    # iterate through each target location
    for target in repo['contents']:
        verbose_print('target: ' + target['directory'])
        
        # iterate throgh each file
        for dotfile in target['files']:
            
            link_dir = repo['location'] + dotfile['name']
            target_dir = target['directory'] + dotfile['name']
            link_dotfile(link_dir, target_dir)
    return


# iterates through all repos stored in json file
def link_all_repos(repos):
    # iterate through repos
    for repo in repos:
        verbose_print('repo: ' + repo['location'])
        link_repo(repo)
    return 


### JSON File Operations ###

# loads the json file into a dictionary
# fails if cannot read or json is malformed 
def load_repos_from_json(filename):
    try:
        with open(filename, 'r') as json_file:
            json_obj = json.load(json_file)
            repos = json_obj['dotdirs']
    except IOError:
        print('error: json file {} doesn\'t exist'.format(filename))
        sys.exit()
    except json.JSONDecodeError:
        print('error: json file {} is malformed'.format(filename))
        sys.exit()
    return repos
    

##TODO: implement add_path 
# adds path to the json file
def add_path_to_json(path, filename, repo_name):
    # load repo
    repos = load_repos_from_json(json_path)
    
    # set repo if can be found
    repo = None 
    for r in repos:
        if r['location'] == repo_name:
            repo = r
    if repo == None:
        print('error: no repo called {}'.format(repo_name))

    # add repo to json dict
    print(repo)
    repo_list = repo['contents']
    # DEBUG return repo for checking
    return repo
    

### Main Function ###

def main():
    add_path_to_json('path_to_file', 'filename', '~/mine/dev/new_dotfiles/')

    process_args()
    #repos = load_repos_from_json(json_path)
    #link_all_repos(repos) 
    return


# run main if executed as script.
# declares all functions before running main
if __name__ == '__main__':
    main()
