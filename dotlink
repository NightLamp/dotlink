#!/usr/bin/python3


desc = '''Dotlink allows the automation of deploying dotfiles to their desired 
 locations on linux systems. It takes advantage of file symlinks to easily keep
 track of changes to files in your dotfiles repository.
'''
# Options:
# -v --verbose
# -h --help
# -f --force
# -a --ask


import json
import subprocess
import sys
import argparse
import os
from pathlib import Path


# globals
G_args = None
working_dir = Path.cwd()
repo_dir = working_dir
json_path = repo_dir / Path('lm.json')




### Helper functions ###

# print msg only if verbose flag is given
def verbose_print(msg):
    if G_args.verbose:
        print(msg)
    return


### User Interface ###

# process cli options and store in G_args
#TODO: -l --link [FILE] 
#TODO: -d --dir 
#TODO: ADD
#TODO: REMOVE
#TODO: LIST
def process_args():
    global G_args
    global repo_dir
    global json_path

    # help messages: 
    verbose_help     = 'be verbose during execution'
    force_help       = 'force overriding existing files'
    interactive_help = 'ask before removing files'
    command_help     = 'what command to execute'
    repo_help        = 'specify a path to the repo holding the dotfiles'
    add_help         = 'add FILE(s) to dotlink'

    # init parser and add arg opts
    parser = argparse.ArgumentParser(description = desc)
    parser.add_argument("-v", "--verbose", help=verbose_help, action='store_true')
    parser.add_argument("-f", "--force", help=force_help, action='store_true')
    parser.add_argument("-i", "--interactive", help=interactive_help, action='store_true')
    parser.add_argument("-r", "--repo", help=repo_help, nargs=1, metavar='DIR')
    #parser.add_argument("-l", "--link", metavar="FILE", nargs='?', help="link the given file to the correct position")
    parser.add_argument("-a", "--add", help=add_help, nargs='+', metavar='FILE')
    G_args = parser.parse_args()

    # set repo path
    if G_args.repo != None:
        new_repo = G_args.repo[0]
        verbose_print('changing repo dir to \'' + str(new_repo) + '\'')
        repo_dir = Path(new_repo)
        json_path = repo_dir / Path('lm.json')

    return 


# ask to execute rm command
def ask_to_remove(path):
    yes = ['y', 'yes', 'Y', 'YES']
    no = ['n', 'no', 'No', 'NO', 'N']
    resp = input('\tremove [{}]? '.format(path))

    if resp in yes:
        return True    
    elif resp in no:
        return False
    else:
        print('error: invalid response')
        sys.exit()
    

### Command Wrappers ###

# calls the link command to make a soft link from 'source' to 'dest'
# is a wrapper for ln
def link_wrapper(source, dest):
    # make symlink 
    link_args = ['ln', '-s', source, dest]
    subprocess.call(link_args)
    return
    

# calls the rm command to remove the file at 'path' recursively
def rm_wrapper(path):
    rm_args = ['rm', '-r', path]
    subprocess.call(rm_args)


### Linking Functions ###


def link_dotfile(target, dotfile):
    
    target = Path(target).expanduser()
    dotfile = Path(repo_dir / dotfile)
    
    # check target and dotfile exist
    if not target.exists(): 
        print('error: ' + str(target) + ' does not exist')
        sys.exit()
    elif not dotfile.exists():
        print('error: ' + str(dotfile.stem) + ' does not exist')
        sys.exit()

    # location that the dotfile will be placed    
    dotfile_location = target / dotfile.stem

    if (dotfile_location.exists()):
        if not G_args.force:
            # ask if its ok to remove offending file
            if G_args.interactive:
                ok_to_remove = ask_to_remove(dotfile_location)
                if ok_to_remove:
                    rm_wrapper(dotfile_location)
                    verbose_print('\trm {}'.format(dotfile_location))
                else:
                    return

        else: # if forced
            rm_wrapper(dotfile_location)
            verbose_print('\trm {}'.format(dotfile_location))
    else: # if file exists
        return 

    link_wrapper(dotfile, target)
    target = str(target)
    dotfile = str(dotfile.stem)
    verbose_print('\tlinking {} to {}'.format(dotfile, target))
    return
          



# stub used to debug linking
def link_dotfile_stub(target, dotfile):

    target = Path(target).expanduser()
    dotfile = Path(repo_dir / dotfile)
    
    # check target and dotfile exist
    if not target.exists() or not dotfile.exists():
        print('error: target or dotfile does not exist')
        sys.exit()

    # print the fake link
    target = str(target)
    dotfile = dotfile.stem
    print('\tlinking \'' + dotfile + '\' to ' + target)    

    return



# links all files within a repo
def link_repo(repo):
    # iterate through each target location
    for target in repo:
        verbose_print('target: ' + target)

        # iterate through each file
        for dotfile in repo[target]:
            #link_dotfile_stub(target, dotfile)
            link_dotfile(target, dotfile)
    return



### JSON File Operations ###

##
# loads the json file into a dictionary. fails if cannot read or json
#  is malformed 
##
def load_repo_from_json(filename):
    try:
        with open(filename, 'r') as json_file:
            repo = json.load(json_file)
    except IOError:
        print('error: json file {} doesn\'t exist'.format(filename))
        sys.exit()
    except json.JSONDecodeError:
        print('error: json file {} is malformed'.format(filename))
        sys.exit()
    return repo
    


## 
# adds a dotfile to the json configuration file. This function can
# optionally be given a target directory to force dotlink to link
# 'dotfile' to a specific directory. If no target is specified, 
# dot file will be linked to the current working directory.
#
# TODO: automatically copy contents to repo?
##
def add_dotfile_to_json(dotfile, target=None):

    repo = load_repo_from_json(json_path)
    
    # set target if not specified
    if target == None:
        target = working_dir

    # compress user dir if present (helps with porting between users)
    target = compressuser(str(target))

    if target in repo:
        if dotfile not in repo[target]:
            repo[target].append(dotfile)
            verbose_print('\'' + dotfile + '\' added to repo')
        else:
            verbose_print('\'' + dotfile + '\' is already in repo') 
    else:
        # init a list in target
        repo[target] = [dotfile]
        verbose_print('\'' + dotfile + '\' added to repo at new target dir')

    # TODO: check it actually saved with no errors
    
    # save repo as json in json_path
    with open(json_path, 'w') as fp:
        json.dump(repo, fp, indent=4)   

    return repo
    


def compressuser(string):   
    home = str(Path.home())
    return string.replace(home, '~')



### Main Function ###

def main():

    process_args()

    if G_args.add != None:
        for dotfile in G_args.add:
            add_dotfile_to_json(dotfile, target=working_dir)
    else:
        repo = load_repo_from_json(json_path)
        link_repo(repo)
    return


# run main if executed as script.
# declares all functions before running main
if __name__ == '__main__':
    main()
